#!/usr/bin/env bash
# Copyright 2025 Jason Dillon
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# bin/cmdo-dev - Development mode bootstrap
#
# Uses packaged tarball with isolated dev-home for development.
# Smart rebuild: only packs/installs when source files change.
# Avoids recursive directory hell by using tarball instead of directory reference.
#
# Usage:
#   ./bin/cmdo-dev [command] [args...]
#   COMMANDO_REBUILD=1 ./bin/cmdo-dev [command]  # Force rebuild
#
set -euo pipefail

#
# Globals
#

PROJECT_ROOT=""
# COMMANDO_HOME set in setup_environment() to dev-home/forge

#
# Path resolution
#

resolve_paths() {
  # Resolve script location (follows symlinks)
  local script_path="${BASH_SOURCE[0]}"
  while [ -L "$script_path" ]; do
    local script_dir="$(cd -P "$(dirname "$script_path")" && pwd)"
    script_path="$(readlink "$script_path")"
    [[ $script_path != /* ]] && script_path="$script_dir/$script_path"
  done
  local script_dir="$(cd -P "$(dirname "$script_path")" && pwd)"

  PROJECT_ROOT="$(cd -P "${script_dir}/.." && pwd)"
  COMMANDO_HOME="${PROJECT_ROOT}/dev-home/commando"
}

setup_environment() {
  # Dev mode: use packaged tarball with isolated dev-home
  export COMMANDO_HOME
  export NODE_PATH="${COMMANDO_HOME}/node_modules"

  # Ensure dev-home forge structure exists
  mkdir -p "${COMMANDO_HOME}"
}

#
# Checksum-based change detection
#

compute_checksum() {
  (
    cd "${PROJECT_ROOT}"
    # Checksum lib/**, package.json, tsconfig.json, bunfig.toml
    (find lib -type f -exec sha256sum {} \; && \
    sha256sum package.json tsconfig.json bunfig.toml 2>/dev/null) | \
    sort | sha256sum | cut -d' ' -f1
  )
}

needs_rebuild() {
  local checksum_file="${COMMANDO_HOME}/.commando-checksum"
  local current=$(compute_checksum)
  local previous=$(cat "$checksum_file" 2>/dev/null || echo "")

  [[ "$current" != "$previous" ]]
}

save_checksum() {
  compute_checksum > "${COMMANDO_HOME}/.commando-checksum"
}

#
# Build steps
#

clear_bun_cache() {
  echo "  → Clearing Bun cache..." >&2
  bun pm cache rm >&2
}

build_tarball() {
  echo "  → Building tarball..." >&2
  local tarball="${PROJECT_ROOT}/build/planet57-commando-dev.tgz"

  # Clean old tarballs to avoid confusion
  rm -f "${tarball}"

  (
    cd "${PROJECT_ROOT}"
    bun pm pack --filename "${tarball}" >&2
  )

  if [[ ! -f "$tarball" ]]; then
    echo "ERROR: Expected tarball not found: $tarball" >&2
    exit 1
  fi

  # Return tarball path to caller (stdout only, all other output to stderr)
  echo "$tarball"
}

create_config_files() {
  local tarball="$1"

  # Create package.json with tarball reference
  cat > "${COMMANDO_HOME}/package.json" << EOF
{
  "name": "commando-dev-home",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@planet57/commando": "file:${tarball}"
  }
}
EOF

  # Create tsconfig.json (simulates what install.sh does) - only if it doesn't exist
  if [[ ! -f "${COMMANDO_HOME}/tsconfig.json" ]]; then
    cat > "${COMMANDO_HOME}/tsconfig.json" << 'EOF'
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@commando/*": ["./node_modules/@planet57/commando/lib/*"]
    }
  }
}
EOF
  fi

  # Create bunfig.toml (simulates what install.sh does) - only if it doesn't exist
  if [[ ! -f "${COMMANDO_HOME}/bunfig.toml" ]]; then
    cat > "${COMMANDO_HOME}/bunfig.toml" << 'EOF'
[install]
exact = true
dev = false
peer = true
optional = false
auto = "disable"
EOF
  fi
}

install_package() {
  echo "  → Installing to dev-home..." >&2

  # Purge old installed package to force fresh install
  rm -rf "${COMMANDO_HOME}/node_modules/@planet57/commando"

  (
    cd "${COMMANDO_HOME}"
    bun install
  )
}

generate_version_info() {
  echo "  → Generating version info..." >&2

  local pkg_dir="${COMMANDO_HOME}/node_modules/@planet57/commando"
  local version=$(node -p "require('${pkg_dir}/package.json').version" 2>/dev/null || echo "dev")

  # Get git info from project root (not the installed package)
  local hash=$(cd "${PROJECT_ROOT}" && git rev-parse --short HEAD 2>/dev/null || echo "dev")
  local hash_full=$(cd "${PROJECT_ROOT}" && git rev-parse HEAD 2>/dev/null || echo "dev")
  local timestamp=$(cd "${PROJECT_ROOT}" && git log -1 --format=%cI HEAD 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")
  local timestamp_unix=$(cd "${PROJECT_ROOT}" && git log -1 --format=%ct HEAD 2>/dev/null || date +%s)
  local branch=$(cd "${PROJECT_ROOT}" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "dev")
  local dirty=$(cd "${PROJECT_ROOT}" && git diff-index --quiet HEAD 2>/dev/null && echo "false" || echo "true")

  # Extract date and time components (YYYYMMDD.HHMM) from timestamp
  # Timestamp format: 2025-11-09T21:28:47Z or 2025-11-09T12:49:29-08:00
  local date_part=$(echo "$timestamp" | cut -d'T' -f1 | tr -d '-')  # 20251109
  local time_part=$(echo "$timestamp" | cut -d'T' -f2 | cut -d':' -f1,2 | tr -d ':')  # 2128
  local date_time="${date_part}.${time_part}"

  # Build semver
  local semver="${version}+${date_time}.${hash}"

  # Write version.json to forge home
  cat > "${COMMANDO_HOME}/version.json" <<EOF
{
  "version": "$version",
  "hash": "$hash",
  "hashFull": "$hash_full",
  "timestamp": "$timestamp",
  "timestampUnix": $timestamp_unix,
  "branch": "$branch",
  "dirty": $dirty,
  "semver": "$semver"
}
EOF
}

rebuild_and_install() {
  echo "" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2
  echo "  Rebuilding commando (source files changed)" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2

  clear_bun_cache
  local tarball=$(build_tarball)
  create_config_files "$tarball"
  install_package
  generate_version_info
  save_checksum

  echo "  ✓ Rebuild complete" >&2
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" >&2
  echo "" >&2
}

#
# Delegate to bin/cmdo
#

run_forge() {
  # Delegate to bin/cmdo script (installed mode bootstrap)
  # It will use our COMMANDO_HOME environment variable
  exec "${PROJECT_ROOT}/bin/cmdo" "$@"
}

#
# Main
#

main() {
  # Initialize paths and environment
  resolve_paths
  setup_environment

  # Check if rebuild needed (or forced via COMMANDO_REBUILD=1)
  if [[ "${COMMANDO_REBUILD:-}" == "1" ]] || needs_rebuild; then
    rebuild_and_install
  fi

  # Delegate to bin/cmdo (will exec, replacing this process)
  # bin/cmdo handles restart logic (exit code 42)
  run_forge "$@"
}

# Execute main with all arguments
main "$@"
